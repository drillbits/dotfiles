'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.createTransform = exports.MarkdownTransform = exports.LaTeXTransform = exports.ScriptTransform = exports.PDFTransform = exports.SVGTransform = exports.HTMLTransform = exports.ImageTransform = exports.TextTransform = exports.Transformime = undefined;

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _text = require('./text.transform');

var _image = require('./image.transform');

var _html = require('./html.transform');

var _svg = require('./svg.transform');

var _pdf = require('./pdf.transform');

var _script = require('./script.transform');

var _latex = require('./latex.transform');

var _commonmark = require('./commonmark.transform');

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

/**
 * Transforms mimetypes into HTMLElements
 */
var Transformime = function () {

  /**
   * Public constructor
   * @param  {function[]} transformers - list of transformers, in reverse priority order.
   */
  function Transformime(transformers) {
    var _this = this;

    _classCallCheck(this, Transformime);

    // Initialize instance variables.
    this.transformers = [];
    this.push(_text.TextTransform);
    this.push(_image.ImageTransform);
    this.push(_svg.SVGTransform);
    this.push(_html.HTMLTransform);
    this.push(_pdf.PDFTransform);
    this.push(_script.ScriptTransform);
    this.push(_commonmark.MarkdownTransform);
    this.push(_latex.LaTeXTransform);
    if (transformers) transformers.forEach(function (transformer) {
      _this.push(transformer);
    });
  }
  /**
   * Transforms a mime bundle, using the richest available representation,
   * into an HTMLElement.
   * @param  {any}      bundle - {mimetype1: data1, mimetype2: data2, ...}
   * @param  {Document} document - Any of window.document, iframe.contentDocument
   * @return {Promise<{mimetype: string, el: HTMLElement}>}
   */


  _createClass(Transformime, [{
    key: 'transform',
    value: function transform(bundle, document) {
      if (this.transformers.length <= 0) {
        // Empty transformers
        return Promise.reject(new Error('No transformers configured'));
      }

      if (Object.keys(bundle).length <= 0) {
        return Promise.reject(new Error('MIME Bundle empty'));
      }

      var richMimetype = void 0;
      var richTransformer = void 0;

      // Choose the last transformer as the most rich
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this.transformers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var transformer = _step.value;

          if (transformer.mimetype) {
            // Make sure the transformer's mimetype is in array format.
            var transformer_mimetypes = transformer.mimetype;
            if (!Array.isArray(transformer_mimetypes)) {
              transformer_mimetypes = [transformer_mimetypes];
            }

            var _iteratorNormalCompletion2 = true;
            var _didIteratorError2 = false;
            var _iteratorError2 = undefined;

            try {
              for (var _iterator2 = transformer_mimetypes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                var transformer_mimetype = _step2.value;

                if (transformer_mimetype in bundle) {
                  richMimetype = transformer_mimetype;
                  richTransformer = transformer;
                }
              }
            } catch (err) {
              _didIteratorError2 = true;
              _iteratorError2 = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion2 && _iterator2.return) {
                  _iterator2.return();
                }
              } finally {
                if (_didIteratorError2) {
                  throw _iteratorError2;
                }
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      if (richMimetype && richTransformer) {
        // Don't assume the transformation will return a promise.  Also
        // don't assume the transformation will succeed.
        try {
          return Promise.resolve(richTransformer.call(richTransformer, richMimetype, bundle[richMimetype], document)).then(function (el) {
            return { mimetype: richMimetype, el: el };
          });
        } catch (e) {
          return Promise.reject(e);
        }
      } else {
        return Promise.reject(new Error('Transformer(s) for ' + Object.keys(bundle).join(', ') + ' not found.'));
      }
    }

    /**
     * Deletes all transformers by mimetype.
     * @param {string|string[]} mimetype - mimetype the data type (e.g. text/plain, text/html, image/png)
     */

  }, {
    key: 'del',
    value: function del(mimetype) {
      // Convert mimetype to an array.
      var mimetypes = mimetype;
      if (!Array.isArray(mimetypes)) {
        mimetypes = [mimetypes];
      }

      // Remove each mimetype.
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = mimetypes[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          mimetype = _step3.value;

          for (var i = 0; i < this.transformers.length; i++) {
            var transformer = this.transformers[i];

            // If the mimetype matches the one we want to remove, remove it.
            if (mimetype === transformer.mimetype) {
              this.transformers.splice(i, 1);
              i--;

              // If the mimetype we want to remove is in the list of the
              // mimetypes supported by the transformer, remove it from the list.
              // If the transformer mimetype list is then empty, remove the
              // transformer.
            } else if (Array.isArray(transformer.mimetype) && mimetype in transformer.mimetype) {
              if (transformer.mimetype.length === 1) {
                this.transformers.splice(i, 1);
                i--;
              } else {
                transformer.mimetype.splice(transformer.mimetype.indexOf(mimetype), 1);
              }
            }
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }
    }

    /**
     * Gets a transformer matching the mimetype
     * @param {string} mimetype - the data type (e.g. text/plain, text/html, image/png)
     * @return {function} Matching transformer
     */

  }, {
    key: 'get',
    value: function get(mimetype) {
      // Loop through the transformers array in reverse.
      for (var i = this.transformers.length - 1; i >= 0; i--) {
        var transformer = this.transformers[i];

        // Get an array of the mimetypes that the transformer supports.
        var transformer_mimetypes = transformer.mimetype;
        if (!Array.isArray(transformer_mimetypes)) {
          transformer_mimetypes = [transformer_mimetypes];
        }

        // Check if any of the mimetypes match the one we are looking for.
        var _iteratorNormalCompletion4 = true;
        var _didIteratorError4 = false;
        var _iteratorError4 = undefined;

        try {
          for (var _iterator4 = transformer_mimetypes[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
            var transformer_mimetype = _step4.value;

            if (mimetype === transformer_mimetype) {
              return transformer;
            }
          }
        } catch (err) {
          _didIteratorError4 = true;
          _iteratorError4 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion4 && _iterator4.return) {
              _iterator4.return();
            }
          } finally {
            if (_didIteratorError4) {
              throw _iteratorError4;
            }
          }
        }
      }
    }

    /**
     * Sets a transformer matching the mimetype
     * @param {string|string[]} mimetype - the data type (e.g. text/plain, text/html, image/png)
     * @param {function} transformer
     * @return {function} inserted transformer function (may be different than arg)
     */

  }, {
    key: 'set',
    value: function set(mimetype, transformer) {
      this.del(mimetype);
      return this.push(transformer, mimetype);
    }

    /**
     * Appends a transformer to the transformer list.
     * @param  {function} transformer
     * @param  {string|string[]} mimetype
     * @return {function} inserted transformer function (may be different than arg)
     */

  }, {
    key: 'push',
    value: function push(transformer, mimetype) {
      // If the mimetype specified is different than the mimetype of the
      // transformer, make a copy of the transformer and set the new mimetype
      // on the copy.
      var transform = transformer;
      if (mimetype && transformer.mimetype !== mimetype) {
        transform = this._proxy(transformer, mimetype);
      }

      // Verify a mimetype is set on the transformer.
      if (!transform.mimetype) throw Error('Could not infer transformer mimetype');

      this.transformers.push(transform);
      return transform;
    }

    /**
     * Create a proxy to a transformer, using another mimetype.
     * @param  {function} transformer
     * @param  {string|string[]} mimetype
     * @return {function} transformer
     */

  }, {
    key: '_proxy',
    value: function _proxy(transformer, mimetype) {
      var transform = function transform() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return transformer.call.apply(transformer, [this].concat(args));
      };
      transform.mimetype = mimetype;
      return transform;
    }
  }]);

  return Transformime;
}();

/**
* Helper to create a function that transforms a MIME bundle into an HTMLElement
* using the given document and list of transformers.
* @param  {function[]} [transformers] List of transformers, in reverse priority order.
* @param  {Document}   [doc]          E.g. window.document, iframe.contentDocument
* @return {function}
*/


function createTransform(transformers, doc) {
  var t = new Transformime(transformers);

  if (!doc) {
    doc = document;
  }

  /**
   * Transforms a MIME bundle into an HTMLElement.
   * @param  {object} bundle {mimetype1: data1, mimetype2: data2, ...}
   * @return {Promise<{mimetype: string, el: HTMLElement}>}
   */
  return function transform(bundle) {
    return t.transform(bundle, doc);
  };
}

exports.Transformime = Transformime;
exports.TextTransform = _text.TextTransform;
exports.ImageTransform = _image.ImageTransform;
exports.HTMLTransform = _html.HTMLTransform;
exports.SVGTransform = _svg.SVGTransform;
exports.PDFTransform = _pdf.PDFTransform;
exports.ScriptTransform = _script.ScriptTransform;
exports.LaTeXTransform = _latex.LaTeXTransform;
exports.MarkdownTransform = _commonmark.MarkdownTransform;
exports.createTransform = createTransform;
//# sourceMappingURL=transformime.js.map