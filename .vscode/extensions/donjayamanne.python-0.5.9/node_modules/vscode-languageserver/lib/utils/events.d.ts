export interface IDisposable {
    dispose(): void;
}
/**
 * Represents a type which can release resources, such
 * as event listening or a timer.
 */
export declare class Disposable implements IDisposable {
    /**
     * Combine many disposable-likes into one. Use this method
     * when having objects with a dispose function which are not
     * instances of Disposable.
     *
     * @return Returns a new disposable which, upon dispose, will
     * dispose all provides disposable-likes.
     */
    static from(...disposables: {
        dispose(): any;
    }[]): Disposable;
    private _callOnDispose;
    constructor(callOnDispose: Function);
    /**
     * Dispose this object.
     */
    dispose(): any;
}
/**
 * Represents a typed event.
 */
export interface Event<T> {
    /**
     *
     * @param listener The listener function will be call when the event happens.
     * @param thisArgs The 'this' which will be used when calling the event listener.
     * @param disposables An array to which a {{IDisposable}} will be added. The
     * @return
    */
    (listener: (e: T) => any, thisArgs?: any, disposables?: IDisposable[]): IDisposable;
}
export declare class CallbackList {
    private _callbacks;
    private _contexts;
    add(callback: Function, context?: any, bucket?: IDisposable[]): void;
    remove(callback: Function, context?: any): void;
    invoke(...args: any[]): any[];
    isEmpty(): boolean;
    dispose(): void;
}
export interface EmitterOptions {
    onFirstListenerAdd?: Function;
    onLastListenerRemove?: Function;
}
export declare class Emitter<T> {
    private _options;
    private static _noop;
    private _event;
    private _callbacks;
    constructor(_options?: EmitterOptions);
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */
    event: Event<T>;
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    fire(event: T): any;
    dispose(): void;
}
