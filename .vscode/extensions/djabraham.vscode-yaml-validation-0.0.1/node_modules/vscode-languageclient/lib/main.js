/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */
'use strict';
var cp = require('child_process');
var vscode_1 = require('vscode');
var vscode_jsonrpc_1 = require('vscode-jsonrpc');
var protocol_1 = require('./protocol');
exports.Position = protocol_1.Position;
exports.Range = protocol_1.Range;
exports.Location = protocol_1.Location;
exports.TextDocumentIdentifier = protocol_1.TextDocumentIdentifier;
exports.TextDocumentPosition = protocol_1.TextDocumentPosition;
var c2p = require('./codeConverter');
var p2c = require('./protocolConverter');
var is = require('./utils/is');
var electron = require('./utils/electron');
var processes_1 = require('./utils/processes');
var async_1 = require('./utils/async');
var Logger = (function () {
    function Logger() {
    }
    Logger.prototype.error = function (message) {
        console.error(message);
    };
    Logger.prototype.warn = function (message) {
        console.warn(message);
    };
    Logger.prototype.info = function (message) {
        console.info(message);
    };
    Logger.prototype.log = function (message) {
        console.log(message);
    };
    return Logger;
})();
function createConnection(input, output) {
    var logger = new Logger();
    var connection = vscode_jsonrpc_1.createClientMessageConnection(input, output, logger);
    var result = {
        listen: function () { return connection.listen(); },
        sendRequest: function (type, params) { return connection.sendRequest(type, params); },
        sendNotification: function (type, params) { return connection.sendNotification(type, params); },
        onNotification: function (type, handler) { return connection.onNotification(type, handler); },
        onRequest: function (type, handler) { return connection.onRequest(type, handler); },
        initialize: function (params) { return connection.sendRequest(protocol_1.InitializeRequest.type, params); },
        shutdown: function () { return connection.sendRequest(protocol_1.ShutdownRequest.type); },
        exit: function () { return connection.sendNotification(protocol_1.ExitNotification.type); },
        onLogMessage: function (handler) { return connection.onNotification(protocol_1.LogMessageNotification.type, handler); },
        onShowMessage: function (handler) { return connection.onNotification(protocol_1.ShowMessageNotification.type, handler); },
        didChangeConfiguration: function (params) { return connection.sendNotification(protocol_1.DidChangeConfigurationNotification.type, params); },
        didChangeWatchedFiles: function (params) { return connection.sendNotification(protocol_1.DidChangeWatchedFilesNotification.type, params); },
        didOpenTextDocument: function (params) { return connection.sendNotification(protocol_1.DidOpenTextDocumentNotification.type, params); },
        didChangeTextDocument: function (params) { return connection.sendNotification(protocol_1.DidChangeTextDocumentNotification.type, params); },
        didCloseTextDocument: function (params) { return connection.sendNotification(protocol_1.DidCloseTextDocumentNotification.type, params); },
        onDiagnostics: function (handler) { return connection.onNotification(protocol_1.PublishDiagnosticsNotification.type, handler); },
        dispose: function () { return connection.dispose(); }
    };
    return result;
}
(function (TransportKind) {
    TransportKind[TransportKind["stdio"] = 0] = "stdio";
    TransportKind[TransportKind["ipc"] = 1] = "ipc";
})(exports.TransportKind || (exports.TransportKind = {}));
var TransportKind = exports.TransportKind;
var ClientState;
(function (ClientState) {
    ClientState[ClientState["Starting"] = 0] = "Starting";
    ClientState[ClientState["Running"] = 1] = "Running";
    ClientState[ClientState["Stopping"] = 2] = "Stopping";
    ClientState[ClientState["Stopped"] = 3] = "Stopped";
})(ClientState || (ClientState = {}));
var FalseSyncExpression = (function () {
    function FalseSyncExpression() {
    }
    FalseSyncExpression.prototype.evaluate = function (textDocument) {
        return false;
    };
    return FalseSyncExpression;
})();
var LanguageIdExpression = (function () {
    function LanguageIdExpression(_id) {
        this._id = _id;
    }
    LanguageIdExpression.prototype.evaluate = function (textDocument) {
        return this._id === textDocument.languageId;
    };
    return LanguageIdExpression;
})();
var FunctionSyncExpression = (function () {
    function FunctionSyncExpression(_func) {
        this._func = _func;
    }
    FunctionSyncExpression.prototype.evaluate = function (textDocument) {
        return this._func(textDocument);
    };
    return FunctionSyncExpression;
})();
var CompositeSyncExpression = (function () {
    function CompositeSyncExpression(values, func) {
        this._expression = values.map(function (value) { return new LanguageIdExpression(value); });
        if (func) {
            this._expression.push(new FunctionSyncExpression(func));
        }
    }
    CompositeSyncExpression.prototype.evaluate = function (textDocument) {
        return this._expression.some(function (exp) { return exp.evaluate(textDocument); });
    };
    return CompositeSyncExpression;
})();
var LanguageClient = (function () {
    function LanguageClient(name, serverOptions, languageOptions, forceDebug) {
        var _this = this;
        if (forceDebug === void 0) { forceDebug = false; }
        this._name = name;
        this._serverOptions = serverOptions;
        this._languageOptions = languageOptions || {};
        this._languageOptions.synchronize = this._languageOptions.synchronize || {};
        this._syncExpression = this.computeSyncExpression();
        this._forceDebug = forceDebug;
        this._state = ClientState.Stopped;
        this._connection = null;
        this._childProcess = null;
        this._outputChannel = null;
        this._listeners = null;
        this._providers = null;
        this._diagnostics = null;
        this._fileEvents = [];
        this._fileEventDelayer = new async_1.Delayer(250);
        this._onReady = new Promise(function (resolve, reject) {
            _this._onReadyCallbacks = { resolve: resolve, reject: reject };
        });
    }
    LanguageClient.prototype.computeSyncExpression = function () {
        var documentSelector = this._languageOptions.documentSelector;
        var textDocumentFilter = this._languageOptions.synchronize.textDocumentFilter;
        if (!documentSelector && !textDocumentFilter) {
            return new FalseSyncExpression();
        }
        if (textDocumentFilter && !documentSelector) {
            return new FunctionSyncExpression(textDocumentFilter);
        }
        if (!textDocumentFilter && documentSelector) {
            if (is.string(documentSelector)) {
                return new LanguageIdExpression(documentSelector);
            }
            else {
                return new CompositeSyncExpression(documentSelector);
            }
        }
        if (textDocumentFilter && documentSelector) {
            return new CompositeSyncExpression(is.string(documentSelector) ? [documentSelector] : documentSelector, textDocumentFilter);
        }
    };
    LanguageClient.prototype.sendRequest = function (type, params) {
        var _this = this;
        return this.onReady().then(function () {
            return _this.resolveConnection().then(function (connection) {
                return _this.doSendRequest(connection, type, params);
            });
        });
    };
    LanguageClient.prototype.doSendRequest = function (connection, type, params) {
        if (this.isConnectionActive()) {
            this.forceDocumentSync();
            return connection.sendRequest(type, params);
        }
        else {
            return Promise.reject(new vscode_jsonrpc_1.ResponseError(vscode_jsonrpc_1.ErrorCodes.InternalError, 'Connection is closed.'));
        }
    };
    LanguageClient.prototype.sendNotification = function (type, params) {
        var _this = this;
        this.onReady().then(function () {
            _this.resolveConnection().then(function (connection) {
                if (_this.isConnectionActive()) {
                    _this.forceDocumentSync();
                    connection.sendNotification(type, params);
                }
            });
        });
    };
    LanguageClient.prototype.onNotification = function (type, handler) {
        var _this = this;
        this.onReady().then(function () {
            _this.resolveConnection().then(function (connection) {
                connection.onNotification(type, handler);
            });
        });
    };
    LanguageClient.prototype.onRequest = function (type, handler) {
        var _this = this;
        this.onReady().then(function () {
            _this.resolveConnection().then(function (connection) {
                connection.onRequest(type, handler);
            });
        });
    };
    LanguageClient.prototype.needsStart = function () {
        return this._state === ClientState.Stopping || this._state === ClientState.Stopped;
    };
    LanguageClient.prototype.needsStop = function () {
        return this._state === ClientState.Starting || this._state === ClientState.Running;
    };
    LanguageClient.prototype.onReady = function () {
        return this._onReady;
    };
    LanguageClient.prototype.isConnectionActive = function () {
        return this._state === ClientState.Running;
    };
    LanguageClient.prototype.start = function () {
        var _this = this;
        this._listeners = [];
        this._providers = [];
        this._diagnostics = this._languageOptions.diagnosticCollectionName
            ? vscode_1.languages.createDiagnosticCollection(this._languageOptions.diagnosticCollectionName)
            : vscode_1.languages.createDiagnosticCollection();
        this._state = ClientState.Starting;
        this.resolveConnection().then(function (connection) {
            connection.onLogMessage(function (message) {
                switch (message.type) {
                    case protocol_1.MessageType.Error:
                        console.error(message.message);
                        break;
                    case protocol_1.MessageType.Warning:
                        console.warn(message.message);
                        break;
                    case protocol_1.MessageType.Info:
                        console.info(message.message);
                        break;
                    default:
                        console.log(message.message);
                }
            });
            connection.onShowMessage(function (message) {
                switch (message.type) {
                    case protocol_1.MessageType.Error:
                        vscode_1.window.showErrorMessage(message.message);
                        break;
                    case protocol_1.MessageType.Warning:
                        vscode_1.window.showWarningMessage(message.message);
                        break;
                    case protocol_1.MessageType.Info:
                        vscode_1.window.showInformationMessage(message.message);
                        break;
                    default:
                        vscode_1.window.showInformationMessage(message.message);
                }
            });
            connection.listen();
            _this.initialize(connection);
        }, function (error) {
            _this._onReadyCallbacks.reject();
            vscode_1.window.showErrorMessage("Couldn't start client " + _this._name);
        });
        return new vscode_1.Disposable(function () {
            if (_this.needsStop()) {
                _this.stop();
            }
        });
    };
    LanguageClient.prototype.resolveConnection = function () {
        if (!this._connection) {
            this._connection = this.createConnection();
        }
        return this._connection;
    };
    LanguageClient.prototype.initialize = function (connection) {
        var _this = this;
        var initParams = { processId: process.pid, rootPath: vscode_1.workspace.rootPath, capabilities: {}, initializationOptions: this._languageOptions.initializationOptions };
        return connection.initialize(initParams).then(function (result) {
            _this._state = ClientState.Running;
            _this._capabilites = result.capabilities;
            connection.onDiagnostics(function (params) { return _this.handleDiagnostics(params); });
            if (_this._capabilites.textDocumentSync !== protocol_1.TextDocumentSyncKind.None) {
                vscode_1.workspace.onDidOpenTextDocument(function (t) { return _this.onDidOpenTextDoument(connection, t); }, null, _this._listeners);
                vscode_1.workspace.onDidChangeTextDocument(function (t) { return _this.onDidChangeTextDocument(connection, t); }, null, _this._listeners);
                vscode_1.workspace.onDidCloseTextDocument(function (t) { return _this.onDidCloseTextDoument(connection, t); }, null, _this._listeners);
                if (_this._capabilites.textDocumentSync === protocol_1.TextDocumentSyncKind.Full) {
                    _this._documentSyncDelayer = new async_1.Delayer(100);
                }
            }
            _this.hookFileEvents(connection);
            _this.hookConfigurationChanged(connection);
            _this.hookCapabilities(connection);
            _this._onReadyCallbacks.resolve();
            vscode_1.workspace.textDocuments.forEach(function (t) { return _this.onDidOpenTextDoument(connection, t); });
            return result;
        }, function (error) {
            if (error.data.retry) {
                vscode_1.window.showErrorMessage(error.message, { title: 'Retry', id: "retry" }).then(function (item) {
                    if (is.defined(item) && item.id === 'retry') {
                        _this.initialize(connection);
                    }
                });
            }
            else {
                _this._onReadyCallbacks.reject();
                vscode_1.window.showErrorMessage(error.message);
            }
        });
    };
    LanguageClient.prototype.stop = function () {
        var _this = this;
        if (!this._connection) {
            this._state = ClientState.Stopped;
            return;
        }
        this._state = ClientState.Stopping;
        // unkook listeners
        this._listeners.forEach(function (listener) { return listener.dispose(); });
        this._listeners = null;
        this._providers.forEach(function (provider) { return provider.dispose(); });
        this._providers = null;
        this._diagnostics.dispose();
        this._diagnostics = null;
        this.resolveConnection().then(function (connection) {
            connection.shutdown().then(function () {
                connection.exit();
                connection.dispose();
                _this._state = ClientState.Stopped;
                _this._connection = null;
                var toCheck = _this._childProcess;
                _this._childProcess = null;
                // Remove all markers
                _this.checkProcessDied(toCheck);
            });
        });
    };
    LanguageClient.prototype.notifyConfigurationChanged = function (settings) {
        var _this = this;
        this.onReady().then(function () {
            _this.resolveConnection().then(function (connection) {
                if (_this.isConnectionActive()) {
                    connection.didChangeConfiguration({ settings: settings });
                }
            }, function (error) {
                console.error("Syncing settings failed with error " + JSON.stringify(error, null, 4));
            });
        });
    };
    LanguageClient.prototype.notifyFileEvent = function (event) {
        var _this = this;
        this._fileEvents.push(event);
        this._fileEventDelayer.trigger(function () {
            _this.onReady().then(function () {
                _this.resolveConnection().then(function (connection) {
                    if (_this.isConnectionActive()) {
                        connection.didChangeWatchedFiles({ changes: _this._fileEvents });
                    }
                    _this._fileEvents = [];
                });
            });
        });
    };
    LanguageClient.prototype.onDidOpenTextDoument = function (connection, textDocument) {
        if (!this._syncExpression.evaluate(textDocument)) {
            return;
        }
        connection.didOpenTextDocument(c2p.asOpenTextDocumentParams(textDocument));
    };
    LanguageClient.prototype.onDidChangeTextDocument = function (connection, event) {
        if (!this._syncExpression.evaluate(event.document)) {
            return;
        }
        var uri = event.document.uri.toString();
        if (this._capabilites.textDocumentSync === protocol_1.TextDocumentSyncKind.Incremental) {
            connection.didChangeTextDocument(c2p.asChangeTextDocumentParams(event));
        }
        else {
            this._documentSyncDelayer.trigger(function () {
                connection.didChangeTextDocument(c2p.asChangeTextDocumentParams(event.document));
            }, -1);
        }
    };
    LanguageClient.prototype.onDidCloseTextDoument = function (connection, textDocument) {
        if (!this._syncExpression.evaluate(textDocument)) {
            return;
        }
        connection.didCloseTextDocument(c2p.asCloseTextDocumentParams(textDocument));
    };
    LanguageClient.prototype.forceDocumentSync = function () {
        if (this._documentSyncDelayer) {
            this._documentSyncDelayer.forceDelivery();
        }
    };
    LanguageClient.prototype.handleDiagnostics = function (params) {
        var uri = vscode_1.Uri.parse(params.uri);
        var diagnostics = p2c.asDiagnostics(params.diagnostics);
        this._diagnostics.set(uri, diagnostics);
    };
    LanguageClient.prototype.createConnection = function () {
        var _this = this;
        var server = this._serverOptions;
        // We got a function.
        if (is.func(server)) {
            return server().then(function (result) {
                var info = result;
                if (info.writer && info.reader) {
                    return createConnection(info.reader, info.writer);
                }
                else {
                    var cp_1 = result;
                    return createConnection(cp_1.stdout, cp_1.stdin);
                }
            });
        }
        var json = null;
        var runDebug = server;
        if (is.defined(runDebug.run) || is.defined(runDebug.debug)) {
            // We are under debugging. So use debug as well.
            if (typeof v8debug === 'object' || this._forceDebug) {
                json = runDebug.debug;
            }
            else {
                json = runDebug.run;
            }
        }
        else {
            json = server;
        }
        if (is.defined(json.module)) {
            var node = json;
            return new Promise(function (resolve, reject) {
                var options = node.options || Object.create(null);
                options.execArgv = options.execArgv || [];
                options.cwd = options.cwd || vscode_1.workspace.rootPath;
                electron.fork(node.module, node.args || [], options, function (error, cp) {
                    if (error) {
                        reject(error);
                    }
                    else {
                        _this._childProcess = cp;
                        if (node.transport === TransportKind.ipc) {
                            _this._outputChannel = vscode_1.window.createOutputChannel(_this._name);
                            cp.stdout.on('data', function (data) {
                                _this._outputChannel.append(data.toString());
                            });
                            resolve(createConnection(new vscode_jsonrpc_1.IPCMessageReader(_this._childProcess), new vscode_jsonrpc_1.IPCMessageWriter(_this._childProcess)));
                        }
                        else {
                            resolve(createConnection(cp.stdout, cp.stdin));
                        }
                    }
                });
            });
        }
        else if (is.defined(json.command)) {
            var command = json;
            var options = command.options || {};
            options.cwd = options.cwd || vscode_1.workspace.rootPath;
            var process_1 = cp.spawn(command.command, command.args, command.options);
            this._childProcess = process_1;
            return Promise.resolve(createConnection(process_1.stdout, process_1.stdin));
        }
        return Promise.reject(new Error("Unsupported server configuartion " + JSON.stringify(server, null, 4)));
    };
    LanguageClient.prototype.checkProcessDied = function (childProcess) {
        setTimeout(function () {
            // Test if the process is still alive. Throws an exception if not
            try {
                process.kill(childProcess.pid, 0);
                processes_1.terminate(childProcess);
            }
            catch (error) {
            }
        }, 2000);
    };
    LanguageClient.prototype.hookConfigurationChanged = function (connection) {
        var _this = this;
        if (!this._languageOptions.synchronize.configurationSection) {
            return;
        }
        vscode_1.workspace.onDidChangeConfiguration(function (e) { return _this.onDidChangeConfiguration(connection); }, this, this._listeners);
        this.onDidChangeConfiguration(connection);
    };
    LanguageClient.prototype.onDidChangeConfiguration = function (connection) {
        var keys = null;
        var configurationSection = this._languageOptions.synchronize.configurationSection;
        if (is.string(configurationSection)) {
            keys = [configurationSection];
        }
        else if (is.stringArray(configurationSection)) {
            keys = configurationSection;
        }
        if (keys) {
            if (this.isConnectionActive()) {
                connection.didChangeConfiguration({ settings: this.extractSettingsInformation(keys) });
            }
        }
    };
    LanguageClient.prototype.extractSettingsInformation = function (keys) {
        function ensurePath(config, path) {
            var current = config;
            for (var i = 0; i < path.length - 1; i++) {
                var obj = current[path[i]];
                if (!obj) {
                    obj = Object.create(null);
                    current[path[i]] = obj;
                }
                current = obj;
            }
            return current;
        }
        vscode_1.workspace.getConfiguration();
        var result = Object.create(null);
        for (var i = 0; i < keys.length; i++) {
            var key = keys[i];
            var index = key.indexOf('.');
            var config = null;
            if (index >= 0) {
                config = vscode_1.workspace.getConfiguration(key.substr(0, index)).get(key.substr(index + 1));
            }
            else {
                config = vscode_1.workspace.getConfiguration(key);
            }
            if (config) {
                var path = keys[i].split('.');
                ensurePath(result, path)[path[path.length - 1]] = config;
            }
        }
        return result;
    };
    LanguageClient.prototype.hookFileEvents = function (connection) {
        var _this = this;
        var fileEvents = this._languageOptions.synchronize.fileEvents;
        if (!fileEvents) {
            return;
        }
        var watchers = null;
        if (is.array(fileEvents)) {
            watchers = fileEvents;
        }
        else {
            watchers = [fileEvents];
        }
        if (!watchers) {
            return;
        }
        watchers.forEach(function (watcher) {
            watcher.onDidCreate(function (resource) { return _this.notifyFileEvent({
                uri: resource.toString(),
                type: protocol_1.FileChangeType.Created
            }); }, null, _this._listeners);
            watcher.onDidChange(function (resource) { return _this.notifyFileEvent({
                uri: resource.toString(),
                type: protocol_1.FileChangeType.Changed
            }); }, null, _this._listeners);
            watcher.onDidDelete(function (resource) { return _this.notifyFileEvent({
                uri: resource.toString(),
                type: protocol_1.FileChangeType.Deleted
            }); }, null, _this._listeners);
        });
    };
    LanguageClient.prototype.hookCapabilities = function (connection) {
        var documentSelector = this._languageOptions.documentSelector;
        if (!documentSelector) {
            return;
        }
        this.hookCompletionProvider(documentSelector, connection);
        this.hookHoverProvider(documentSelector, connection);
        this.hookSignatureHelpProvider(documentSelector, connection);
        this.hookDefinitionProvider(documentSelector, connection);
        this.hookReferencesProvider(documentSelector, connection);
        this.hookDocumentHighlightProvider(documentSelector, connection);
        this.hookDocumentSymbolProvider(documentSelector, connection);
        this.hookWorkspaceSymbolProvider(connection);
        this.hookCodeActionsProvider(documentSelector, connection);
        this.hookCodeLensProvider(documentSelector, connection);
        this.hookDocumentFormattingProvider(documentSelector, connection);
        this.hookDocumentRangeFormattingProvider(documentSelector, connection);
        this.hookDocumentOnTypeFormattingProvider(documentSelector, connection);
        this.hookRenameProvider(documentSelector, connection);
    };
    LanguageClient.prototype.hookCompletionProvider = function (documentSelector, connection) {
        var _this = this;
        if (!this._capabilites.completionProvider) {
            return;
        }
        this._providers.push(vscode_1.languages.registerCompletionItemProvider.apply(vscode_1.languages, [documentSelector, {
            provideCompletionItems: function (document, position, token) {
                return _this.doSendRequest(connection, protocol_1.CompletionRequest.type, c2p.asTextDocumentPosition(document, position)).then(p2c.asCompletionResult, function (error) { return Promise.resolve([]); });
            },
            resolveCompletionItem: this._capabilites.completionProvider.resolveProvider
                ? function (item, token) {
                    return _this.doSendRequest(connection, protocol_1.CompletionResolveRequest.type, c2p.asCompletionItem(item)).then(p2c.asCompletionItem, function (error) { return Promise.resolve(item); });
                }
                : undefined
        }].concat(this._capabilites.completionProvider.triggerCharacters)));
    };
    LanguageClient.prototype.hookHoverProvider = function (documentSelector, connection) {
        var _this = this;
        if (!this._capabilites.hoverProvider) {
            return;
        }
        this._providers.push(vscode_1.languages.registerHoverProvider(documentSelector, {
            provideHover: function (document, position, token) {
                return _this.doSendRequest(connection, protocol_1.HoverRequest.type, c2p.asTextDocumentPosition(document, position)).then(p2c.asHover, function (error) { return Promise.resolve(null); });
            }
        }));
    };
    LanguageClient.prototype.hookSignatureHelpProvider = function (documentSelector, connection) {
        var _this = this;
        if (!this._capabilites.signatureHelpProvider) {
            return;
        }
        this._providers.push(vscode_1.languages.registerSignatureHelpProvider.apply(vscode_1.languages, [documentSelector, {
            provideSignatureHelp: function (document, position, token) {
                return _this.doSendRequest(connection, protocol_1.SignatureHelpRequest.type, c2p.asTextDocumentPosition(document, position)).then(p2c.asSignatureHelp, function (error) { return Promise.resolve(null); });
            }
        }].concat(this._capabilites.signatureHelpProvider.triggerCharacters)));
    };
    LanguageClient.prototype.hookDefinitionProvider = function (documentSelector, connection) {
        var _this = this;
        if (!this._capabilites.definitionProvider) {
            return;
        }
        this._providers.push(vscode_1.languages.registerDefinitionProvider(documentSelector, {
            provideDefinition: function (document, position, token) {
                return _this.doSendRequest(connection, protocol_1.DefinitionRequest.type, c2p.asTextDocumentPosition(document, position)).then(p2c.asDefinitionResult, function (error) { return Promise.resolve(null); });
            }
        }));
    };
    LanguageClient.prototype.hookReferencesProvider = function (documentSelector, connection) {
        var _this = this;
        if (!this._capabilites.referencesProvider) {
            return;
        }
        this._providers.push(vscode_1.languages.registerReferenceProvider(documentSelector, {
            provideReferences: function (document, position, options, token) {
                return _this.doSendRequest(connection, protocol_1.ReferencesRequest.type, c2p.asReferenceParams(document, position, options)).then(p2c.asReferences, function (error) { return Promise.resolve([]); });
            }
        }));
    };
    LanguageClient.prototype.hookDocumentHighlightProvider = function (documentSelector, connection) {
        var _this = this;
        if (!this._capabilites.documentHighlightProvider) {
            return;
        }
        this._providers.push(vscode_1.languages.registerDocumentHighlightProvider(documentSelector, {
            provideDocumentHighlights: function (document, position, token) {
                return _this.doSendRequest(connection, protocol_1.DocumentHighlightRequest.type, c2p.asTextDocumentPosition(document, position)).then(p2c.asDocumentHighlights, function (error) { return Promise.resolve([]); });
            }
        }));
    };
    LanguageClient.prototype.hookDocumentSymbolProvider = function (documentSelector, connection) {
        var _this = this;
        if (!this._capabilites.documentSymbolProvider) {
            return;
        }
        this._providers.push(vscode_1.languages.registerDocumentSymbolProvider(documentSelector, {
            provideDocumentSymbols: function (document, token) {
                return _this.doSendRequest(connection, protocol_1.DocumentSymbolRequest.type, c2p.asTextDocumentIdentifier(document)).then(p2c.asSymbolInformations, function (error) { return Promise.resolve([]); });
            }
        }));
    };
    LanguageClient.prototype.hookWorkspaceSymbolProvider = function (connection) {
        var _this = this;
        if (!this._capabilites.workspaceSymbolProvider) {
            return;
        }
        this._providers.push(vscode_1.languages.registerWorkspaceSymbolProvider({
            provideWorkspaceSymbols: function (query, token) {
                return _this.doSendRequest(connection, protocol_1.WorkspaceSymbolRequest.type, { query: query }).then(p2c.asSymbolInformations, function (error) { return Promise.resolve([]); });
            }
        }));
    };
    LanguageClient.prototype.hookCodeActionsProvider = function (documentSelector, connection) {
        var _this = this;
        if (!this._capabilites.codeActionProvider) {
            return;
        }
        this._providers.push(vscode_1.languages.registerCodeActionsProvider(documentSelector, {
            provideCodeActions: function (document, range, context, token) {
                var params = {
                    textDocument: c2p.asTextDocumentIdentifier(document),
                    range: c2p.asRange(range),
                    context: c2p.asCodeActionContext(context)
                };
                return _this.doSendRequest(connection, protocol_1.CodeActionRequest.type, params).then(p2c.asCommands, function (error) { return Promise.resolve([]); });
            }
        }));
    };
    LanguageClient.prototype.hookCodeLensProvider = function (documentSelector, connection) {
        var _this = this;
        if (!this._capabilites.codeLensProvider) {
            return;
        }
        this._providers.push(vscode_1.languages.registerCodeLensProvider(documentSelector, {
            provideCodeLenses: function (document, token) {
                return _this.doSendRequest(connection, protocol_1.CodeLensRequest.type, c2p.asTextDocumentIdentifier(document)).then(p2c.asCodeLenses, function (error) { return Promise.resolve([]); });
            },
            resolveCodeLens: (this._capabilites.codeLensProvider.resolveProvider)
                ? function (codeLens, token) {
                    return _this.doSendRequest(connection, protocol_1.CodeLensResolveRequest.type, c2p.asCodeLens(codeLens)).then(p2c.asCodeLens, function (error) { return codeLens; });
                }
                : undefined
        }));
    };
    LanguageClient.prototype.hookDocumentFormattingProvider = function (documentSelector, connection) {
        var _this = this;
        if (!this._capabilites.documentFormattingProvider) {
            return;
        }
        this._providers.push(vscode_1.languages.registerDocumentFormattingEditProvider(documentSelector, {
            provideDocumentFormattingEdits: function (document, options, token) {
                var params = {
                    textDocument: c2p.asTextDocumentIdentifier(document),
                    options: c2p.asFormattingOptions(options)
                };
                return _this.doSendRequest(connection, protocol_1.DocumentFormattingRequest.type, params).then(p2c.asTextEdits, function (error) { return Promise.resolve([]); });
            }
        }));
    };
    LanguageClient.prototype.hookDocumentRangeFormattingProvider = function (documentSelector, connection) {
        var _this = this;
        if (!this._capabilites.documentRangeFormattingProvider) {
            return;
        }
        this._providers.push(vscode_1.languages.registerDocumentRangeFormattingEditProvider(documentSelector, {
            provideDocumentRangeFormattingEdits: function (document, range, options, token) {
                var params = {
                    textDocument: c2p.asTextDocumentIdentifier(document),
                    range: c2p.asRange(range),
                    options: c2p.asFormattingOptions(options)
                };
                return _this.doSendRequest(connection, protocol_1.DocumentRangeFormattingRequest.type, params).then(p2c.asTextEdits, function (error) { return Promise.resolve([]); });
            }
        }));
    };
    LanguageClient.prototype.hookDocumentOnTypeFormattingProvider = function (documentSelector, connection) {
        var _this = this;
        if (!this._capabilites.documentOnTypeFormattingProvider) {
            return;
        }
        var formatCapabilities = this._capabilites.documentOnTypeFormattingProvider;
        this._providers.push(vscode_1.languages.registerOnTypeFormattingEditProvider.apply(vscode_1.languages, [documentSelector, {
            provideOnTypeFormattingEdits: function (document, position, ch, options, token) {
                var params = {
                    textDocument: c2p.asTextDocumentIdentifier(document),
                    position: c2p.asPosition(position),
                    ch: ch,
                    options: c2p.asFormattingOptions(options)
                };
                return _this.doSendRequest(connection, protocol_1.DocumentOnTypeFormattingRequest.type, params).then(p2c.asTextEdits, function (error) { return Promise.resolve([]); });
            }
        }, formatCapabilities.firstTriggerCharacter].concat(formatCapabilities.moreTriggerCharacter)));
    };
    LanguageClient.prototype.hookRenameProvider = function (documentSelector, connection) {
        var _this = this;
        if (!this._capabilites.renameProvider) {
            return;
        }
        this._providers.push(vscode_1.languages.registerRenameProvider(documentSelector, {
            provideRenameEdits: function (document, position, newName, token) {
                var params = {
                    textDocument: c2p.asTextDocumentIdentifier(document),
                    position: c2p.asPosition(position),
                    newName: newName
                };
                return _this.doSendRequest(connection, protocol_1.RenameRequest.type, params).then(p2c.asWorkspaceEdit, function (error) { return Promise.resolve(new Error(error.message)); });
            }
        }));
    };
    return LanguageClient;
})();
exports.LanguageClient = LanguageClient;
var SettingMonitor = (function () {
    function SettingMonitor(_client, _setting) {
        this._client = _client;
        this._setting = _setting;
        this._listeners = [];
    }
    SettingMonitor.prototype.start = function () {
        var _this = this;
        vscode_1.workspace.onDidChangeConfiguration(this.onDidChangeConfiguration, this, this._listeners);
        this.onDidChangeConfiguration();
        return new vscode_1.Disposable(function () {
            if (_this._client.needsStop()) {
                _this._client.stop();
            }
        });
    };
    SettingMonitor.prototype.onDidChangeConfiguration = function () {
        var index = this._setting.indexOf('.');
        var primary = index >= 0 ? this._setting.substr(0, index) : this._setting;
        var rest = index >= 0 ? this._setting.substr(index + 1) : undefined;
        var enabled = rest ? vscode_1.workspace.getConfiguration(primary).get(rest, false) : vscode_1.workspace.getConfiguration(primary);
        if (enabled && this._client.needsStart()) {
            this._client.start();
        }
        else if (!enabled && this._client.needsStop()) {
            this._client.stop();
        }
    };
    return SettingMonitor;
})();
exports.SettingMonitor = SettingMonitor;
